<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自然弯曲碳纳米管生成器 V3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; color: #334155; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* 紧凑型面板 */
        .glass-panel {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            color: #f1f5f9;
        }
        
        /* 紧凑型滑块 */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: #38bdf8;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -4px;
        }
    </style>
</head>
<body>

    <!-- 紧凑控制面板 -->
    <div class="absolute top-4 left-4 w-64 p-4 rounded-xl glass-panel z-10 flex flex-col gap-3 text-sm scale-90 origin-top-left">
        <h1 class="font-bold text-white flex items-center gap-2 text-base border-b border-gray-700 pb-2">
            <span class="w-3 h-3 rounded-full bg-sky-500"></span>
            碳纳米管生成器
        </h1>

        <!-- 长度 -->
        <div class="flex flex-col gap-1">
            <div class="flex justify-between text-xs text-gray-400">
                <span>长度 (层数)</span>
                <span id="length-val" class="text-sky-300 font-mono">200</span>
            </div>
            <input type="range" id="length-slider" min="10" max="1000" value="200">
        </div>

        <!-- 半径 -->
        <div class="flex flex-col gap-1">
            <div class="flex justify-between text-xs text-gray-400">
                <span>半径 (原子数)</span>
                <span id="radius-val" class="text-sky-300 font-mono">10</span>
            </div>
            <input type="range" id="radius-slider" min="5" max="40" value="10" step="1">
        </div>

        <!-- 弯曲度 -->
        <div class="flex flex-col gap-1">
            <div class="flex justify-between text-xs text-gray-400">
                <span>弯曲度 (支持卷曲)</span>
                <span id="bend-val" class="text-sky-300 font-mono">50</span>
            </div>
            <input type="range" id="bend-slider" min="0" max="100" value="50">
        </div>

        <!-- 数据统计 -->
        <div class="grid grid-cols-2 gap-2 text-[10px] bg-black/30 p-2 rounded border border-gray-700/50">
            <span class="text-gray-500">原子:</span>
            <span id="atom-count" class="text-right font-mono text-gray-200">-</span>
            <span class="text-gray-500">化学键:</span>
            <span id="bond-count" class="text-right font-mono text-gray-200">-</span>
        </div>

        <!-- 按钮组 -->
        <div class="grid grid-cols-2 gap-2 mt-1">
            <button id="reset-cam" class="bg-slate-700 hover:bg-slate-600 py-1.5 rounded text-xs transition">重置视角</button>
            <button id="download-btn" class="bg-sky-700 hover:bg-sky-600 py-1.5 rounded text-xs transition">截图</button>
        </div>
    </div>

    <!-- 加载状态 -->
    <div id="loader" class="absolute top-4 right-4 bg-white/90 text-slate-800 text-xs px-3 py-1 rounded shadow-lg hidden font-medium border border-slate-200 z-50">
        生成模型中...
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- 3D 场景配置 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // 1. 纯白背景
        scene.background = new THREE.Color(0xffffff);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20000);
        camera.position.set(400, 400, 800);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 灯光设置 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(200, 500, 300);
        dirLight.castShadow = true;
        // 扩大阴影范围
        const d = 1500;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.mapSize.width = 4096; // 提高阴影精度
        dirLight.shadow.mapSize.height = 4096;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xccddff, 0.3);
        fillLight.position.set(-200, 0, -200);
        scene.add(fillLight);

        // --- 材质 ---
        
        const atomGeometry = new THREE.SphereGeometry(1.4, 16, 16); 
        const atomMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,    
            roughness: 0.5,     
            metalness: 0.1
        });

        // 几何体原点设在中心
        const bondGeometry = new THREE.CylinderGeometry(0.35, 0.35, 1, 6);
        bondGeometry.rotateX(Math.PI / 2); 
        
        const bondMaterial = new THREE.MeshStandardMaterial({
            color: 0x64748b, 
            roughness: 0.5,
            metalness: 0.1
        });

        let atomMesh = null;
        let bondMesh = null;

        // 临时变量
        const _v3_1 = new THREE.Vector3();
        const _v3_2 = new THREE.Vector3();
        const _dummy = new THREE.Object3D();

        // --- 核心逻辑 ---
        
        function generateCNT() {
            document.getElementById('loader').classList.remove('hidden');
            requestAnimationFrame(() => {
                setTimeout(buildModel, 20);
            });
        }

        function buildModel() {
            const lengthLayers = parseInt(document.getElementById('length-slider').value);
            const radiusAtoms = parseInt(document.getElementById('radius-slider').value);
            const bendFactor = parseInt(document.getElementById('bend-slider').value);

            // 清理
            if (atomMesh) { scene.remove(atomMesh); atomMesh.dispose(); }
            if (bondMesh) { scene.remove(bondMesh); bondMesh.dispose(); }

            // --- 比例校准 ---
            const BOND_LENGTH = 5.0; 
            const tubeRadius = (radiusAtoms * BOND_LENGTH) / (2 * Math.PI);
            const layerHeight = BOND_LENGTH * 0.85; 

            // --- 1. 生成螺旋/自然弯曲样条曲线 ---
            const totalHeight = lengthLayers * layerHeight;
            const points = [];
            
            // 为了保证大卷曲时的平滑度，增加采样密度
            const segments = Math.max(50, Math.floor(lengthLayers / 2));
            
            // 弯曲参数计算
            // bendFactor 0 -> 直线
            // bendFactor 100 -> 3圈 (3 * 2PI)
            const maxLoops = 3.0;
            const currentLoops = (bendFactor / 100) * maxLoops;
            const totalAngle = currentLoops * Math.PI * 2;
            
            // 螺旋半径计算逻辑：
            // 当管子变弯时，它的垂直高度应该收缩，水平半径应该变大。
            // 这是一个经验公式，用于保持视觉上的体积感
            const spiralRadius = totalHeight / (Math.max(1, currentLoops * 10) + 5);
            // 垂直压缩比：卷得越多，垂直拉伸越少（变成弹簧）
            const heightScale = 1 - (bendFactor / 100) * 0.8; 

            // 噪声幅度 (保持微观的自然抖动)
            const noiseScale = Math.min(20, totalHeight * 0.05);

            for (let i = 0; i <= segments; i++) {
                const t = i / segments; // 0 to 1
                
                // 基础坐标
                let x, y, z;

                if (bendFactor < 5) {
                    // 几乎是直线，只保留微小的噪声
                    x = 0;
                    z = 0;
                    y = (t - 0.5) * totalHeight;
                } else {
                    // 螺旋逻辑
                    // 角度随 t 线性增加
                    const theta = (t - 0.5) * totalAngle;
                    
                    x = Math.cos(theta) * spiralRadius;
                    z = Math.sin(theta) * spiralRadius;
                    y = (t - 0.5) * totalHeight * heightScale;
                }

                // 叠加自然噪声 (Perlin-like superposition)
                // 即使卷成圈，管壁也不是完美的几何圆
                const f1 = 3.5, f2 = 5.2;
                const noiseX = Math.sin(t * f1 * 2) * noiseScale * 0.2;
                const noiseY = Math.cos(t * f2 * 2) * noiseScale * 0.2;
                const noiseZ = Math.sin(t * f2 * 1.5) * noiseScale * 0.2;

                points.push(new THREE.Vector3(x + noiseX, y + noiseY, z + noiseZ));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            // 重新参数化并计算 Frenet 标架 (用于确定原子的法线方向)
            const frenetFrames = curve.computeFrenetFrames(lengthLayers, false);

            // --- 2. 准备数据 ---
            const totalAtoms = lengthLayers * radiusAtoms;
            // 估算键数量
            const estBonds = totalAtoms * 3;
            
            atomMesh = new THREE.InstancedMesh(atomGeometry, atomMaterial, totalAtoms);
            bondMesh = new THREE.InstancedMesh(bondGeometry, bondMaterial, estBonds);
            
            atomMesh.castShadow = true; atomMesh.receiveShadow = true;
            bondMesh.castShadow = true; bondMesh.receiveShadow = true;

            const atomPositions = []; 

            // --- 3. 计算原子位置 ---
            let atomCount = 0;
            const angleStep = (Math.PI * 2) / radiusAtoms;

            for (let i = 0; i < lengthLayers; i++) {
                const t = i / Math.max(1, lengthLayers - 1);
                const spinePos = curve.getPointAt(t);
                
                const normal = frenetFrames.normals[i];
                const binormal = frenetFrames.binormals[i];

                const layerAtoms = [];
                // 模拟Armchair结构的错位
                const angleOffset = (i % 2 === 0) ? 0 : angleStep / 2;

                for (let j = 0; j < radiusAtoms; j++) {
                    const angle = j * angleStep + angleOffset;
                    
                    const localX = Math.cos(angle) * tubeRadius;
                    const localY = Math.sin(angle) * tubeRadius;

                    // WorldPos = Spine + N*x + B*y
                    _v3_1.copy(spinePos)
                        .addScaledVector(normal, localX)
                        .addScaledVector(binormal, localY);
                    
                    const pos = _v3_1.clone();
                    layerAtoms.push(pos);

                    // 设置原子实例
                    _dummy.position.copy(pos);
                    _dummy.rotation.set(0,0,0);
                    _dummy.scale.set(1, 1, 1);
                    _dummy.updateMatrix();
                    atomMesh.setMatrixAt(atomCount++, _dummy.matrix);
                }
                atomPositions.push(layerAtoms);
            }

            // --- 4. 生成化学键 ---
            let bondCount = 0;
            // 稍微放宽阈值以适应弯曲带来的形变
            const bondThreshold = BOND_LENGTH * 1.45; 

            const createBond = (p1, p2) => {
                const dist = p1.distanceTo(p2);
                if (dist > bondThreshold) return; 

                // 连接两点中心
                _v3_2.addVectors(p1, p2).multiplyScalar(0.5); 
                
                _dummy.position.copy(_v3_2);
                _dummy.lookAt(p2); 
                _dummy.scale.set(1, 1, dist); 
                _dummy.updateMatrix();
                
                bondMesh.setMatrixAt(bondCount++, _dummy.matrix);
            };

            for (let i = 0; i < lengthLayers; i++) {
                for (let j = 0; j < radiusAtoms; j++) {
                    const p1 = atomPositions[i][j];

                    // 连接同层下一个
                    const p2 = atomPositions[i][(j + 1) % radiusAtoms];
                    createBond(p1, p2);

                    // 连接下一层
                    if (i < lengthLayers - 1) {
                        const candidates = [
                            j, 
                            (j + 1) % radiusAtoms,
                            (j - 1 + radiusAtoms) % radiusAtoms
                        ];
                        
                        for (let idx of candidates) {
                            const pNext = atomPositions[i+1][idx];
                            createBond(p1, pNext);
                        }
                    }
                }
            }

            atomMesh.instanceMatrix.needsUpdate = true;
            bondMesh.instanceMatrix.needsUpdate = true;
            bondMesh.count = bondCount;

            scene.add(atomMesh);
            scene.add(bondMesh);

            document.getElementById('atom-count').innerText = atomCount;
            document.getElementById('bond-count').innerText = bondCount;
            document.getElementById('loader').classList.add('hidden');
            
            // 如果是第一次生成，或者手动重置过，这里不强制重置相机
            // 但如果生成的模型非常大，可能需要调整相机视角
        }

        // --- 交互 ---
        const sliders = ['length-slider', 'radius-slider', 'bend-slider'];
        const valIds = ['length-val', 'radius-val', 'bend-val'];
        
        sliders.forEach((id, index) => {
            const el = document.getElementById(id);
            el.addEventListener('input', (e) => {
                document.getElementById(valIds[index]).innerText = e.target.value;
            });
            el.addEventListener('change', generateCNT);
        });

        document.getElementById('reset-cam').addEventListener('click', () => {
            controls.reset();
            camera.position.set(400, 400, 800);
        });

        document.getElementById('download-btn').addEventListener('click', () => {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = 'nanotube_coiled.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // 初始化
        generateCNT();
        animate();

    </script>
</body>
</html>